# Invoice Manager - Cursor Rules

## Project Overview
This is an Invoice Management System for construction/contracting business with Hebrew UI (RTL). Built with vanilla JavaScript (ES6 modules), Firebase/Firestore, and Tailwind CSS.

## Architecture & Code Organization

### Modular Component Structure
- **Always maintain the modular architecture**: Each feature has its own component file
- **Components location**: `public/js/components/` (clients.js, projects.js, orders.js, suppliers.js, sidur.js, settings.js)
- **Shared code**: Use `public/js/shared/` for constants, state, and utilities
- **Views**: Optional view renderers in `public/js/views/`
- **Main coordinator**: `public/js/app.js` initializes and coordinates all components

### Component Pattern
```javascript
// Each component should follow this pattern:
export function initComponentName(context) {
    const { state, db, firebase, storage } = context;
    
    async function functionName() {
        // Implementation
    }
    
    return {
        functionName,
        // Export all public functions
    };
}
```

### When Adding Features
- **Client features** â†’ `components/clients.js`
- **Project/invoice features** â†’ `components/projects.js`
- **Order features** â†’ `components/orders.js`
- **Supplier features** â†’ `components/suppliers.js`
- **Work schedule (×¡×™×“×•×¨ ×¢×‘×•×“×”)** â†’ `components/sidur.js`
- **Shared constants** (categories, statuses, workers) â†’ `shared/constants.js`
- **Helper functions** â†’ `shared/utils.js`
- **State management** â†’ `shared/state.js`

## Firebase/Firestore Patterns

### Database Collections
- `clients` - Client information
- `projects` - Projects (subcollection of clients)
- `invoices` - Invoices (subcollection of projects)
- `suppliers` - Supplier information
- `orders` - Purchase orders
- `workAssignments` - Work schedule (×¡×™×“×•×¨ ×¢×‘×•×“×”)

### Firestore Best Practices
- Always use async/await with Firestore operations
- Handle errors gracefully with try-catch blocks
- Use batch operations for multiple writes when possible
- Use subcollections for hierarchical data (projects under clients, invoices under projects)
- Always update local state after successful Firestore operations

Example:
```javascript
try {
    const docRef = await db.collection('clients').add(data);
    // Update local state
    state.clients.push({ id: docRef.id, ...data });
    render();
} catch (error) {
    console.error('Error adding client:', error);
    alert('×©×’×™××” ×‘×”×•×¡×¤×ª ×œ×§×•×—');
}
```

## State Management

### Centralized State
- All state is managed in `shared/state.js`
- Never create duplicate state objects
- Always use the shared state instance
- Update state before calling `render()`

### State Update Pattern
```javascript
// Read state
const currentClient = state.selectedClient;

// Update state
state.view = 'projects';
state.selectedClient = clientId;

// Always render after state changes
render();
```

## JavaScript Code Style

### ES6 Modules
- Always use ES6 import/export syntax
- Use named exports for clarity
- Import only what you need

### Async/Await
- Prefer async/await over promise chains
- Always handle errors with try-catch
- Show user feedback for async operations

### Naming Conventions
- **Functions**: camelCase (loadClients, addProject)
- **Constants**: UPPER_SNAKE_CASE or camelCase for arrays/objects
- **Components**: initComponentName pattern
- **Event handlers**: handle* or on* prefix (handleSubmit, onClick)

## Hebrew Language Support

### RTL (Right-to-Left)
- Use `dir="rtl"` on HTML elements
- Use Tailwind's RTL utilities where needed
- All user-facing text should be in Hebrew
- Code comments can be in English
- Variable names should be in English

### Hebrew UI Text Examples
- "×”×•×¡×£ ×œ×§×•×—" (Add client)
- "×¤×¨×•×™×§×˜ ×—×“×©" (New project)
- "×”×–×× ×ª ×¨×›×©" (Purchase order)
- "×¡×™×“×•×¨ ×¢×‘×•×“×”" (Work schedule)
- "×—×©×‘×•× ×™×ª" (Invoice)

## Styling

### Tailwind CSS
- Use Tailwind utility classes
- Maintain consistent spacing: space-y-4, gap-4, p-4, etc.
- Use semantic color classes: bg-blue-500, text-gray-700, etc.
- Responsive design: mobile-first approach

### Common Patterns
- Cards: `bg-white rounded-lg shadow-sm p-4`
- Buttons: `bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600`
- Forms: `space-y-4` for form groups
- Modals: Use fixed positioning with backdrop

### Footer Requirements
**ALWAYS APPLY: Version & Branch Display**
- âœ… Footer MUST always display current version number and branch name
- Format: `v{version} | {branch-name} {emoji}`
- Example: `v1.3.5 | settings-fix ğŸ”§`
- Example: `v1.4.0 | main âœ…`
- Example: `v1.3.6 | order-pdf-update ğŸ“„`
- Get version from package.json
- Get branch name dynamically or display current working branch
- Update footer whenever version or branch changes

## Data Formatting

### Utilities Available
Use functions from `shared/utils.js`:
- `formatDate(date)` - Format dates for display
- `formatCurrency(amount)` - Format currency (â‚ª1,000)
- `getStatusColorClass(status)` - Get Tailwind color classes
- `getHebrewDayName(date)` - Hebrew day names
- `getHebrewMonthName(date)` - Hebrew month names
- `calculateTotals(project, state)` - Calculate project financials

### Date Handling
```javascript
// Always use Israeli locale for dates
const date = new Date().toLocaleDateString('he-IL');
// Or use formatDate utility
const formatted = formatDate(new Date());
```

### Currency
- Always show currency with â‚ª symbol
- Format large numbers with commas: â‚ª10,000
- Use `formatCurrency()` utility function

## Testing

### âš ï¸ Testing Strategy: Production Branch Testing
**CRITICAL: Testing is done on PRODUCTION using version control and branches**

- âœ… Deploy feature branch to production
- âœ… Test manually on production with deployed branch
- âœ… Verify all functionality works in production environment
- âŒ NO staging environment - testing happens on live production
- âš ï¸ Only merge to main AFTER successful testing on production branch

### Manual Testing Workflow
1. Create feature branch
2. Deploy branch to production: `firebase deploy`
3. Test manually on production Firebase hosting
4. Verify all features work correctly
5. If tests pass â†’ request merge to main
6. If tests fail â†’ fix issues, commit, deploy, test again
7. After merge to main â†’ deploy main branch

### Jest Configuration (Optional Unit Tests)
- Test files: `tests/**/*.test.js`
- Run tests: `npm test`
- Watch mode: `npm test:watch`
- Coverage: `npm test:coverage`

### Test Structure
- Unit tests â†’ `tests/unit/`
- Integration tests â†’ `tests/integration/`
- UI tests â†’ `tests/ui/`
- E2E tests â†’ `tests/e2e/`

### Writing Tests
```javascript
describe('Component Name', () => {
    test('should do something', () => {
        // Arrange
        const input = 'test';
        
        // Act
        const result = functionToTest(input);
        
        // Assert
        expect(result).toBe(expected);
    });
});
```

## File Operations

### Storage (Firebase Storage)
- Store files in organized paths: `clients/{clientId}/files/`
- Handle file uploads with progress indicators
- Always validate file types and sizes
- Clean up orphaned files when deleting records

## Error Handling

### User Feedback
- Show Hebrew error messages to users
- Log detailed English errors to console
- Use alerts for critical errors
- Use success messages for confirmations

Example:
```javascript
try {
    await operation();
    alert('×”×¤×¢×•×œ×” ×‘×•×¦×¢×” ×‘×”×¦×œ×—×”');
} catch (error) {
    console.error('Detailed error:', error);
    alert('×©×’×™××”: ×”×¤×¢×•×œ×” × ×›×©×œ×”');
}
```

## Performance

### Optimization Guidelines
- Load data only when needed
- Use pagination for large lists
- Debounce search inputs
- Cache frequently accessed data in state
- Minimize DOM manipulation

## Security

### Best Practices
- Never expose Firebase config secrets in client code
- Use Firestore security rules (see `firestore.rules`)
- Validate all user inputs
- Sanitize data before displaying
- Use Firebase Authentication when needed

## Development Workflow

### Local Development
- Use Firebase emulators: `npm run serve`
- Start local server: `start-local.bat`
- Run tests before committing
- Check console for errors

### Before Committing
1. Run tests: `npm test`
2. Check for console errors
3. Test in browser
4. Update CHANGELOG.md if needed
5. Verify Hebrew RTL display

## Documentation

### Code Comments
- Add JSDoc comments for exported functions
- Explain complex logic with inline comments
- Keep comments up-to-date
- Document component initialization

### Component Documentation
Each component should have a header comment:
```javascript
/**
 * Component Name - Brief description
 * 
 * Responsibilities:
 * - Feature 1
 * - Feature 2
 * 
 * Exported functions:
 * - function1() - Description
 * - function2() - Description
 */
```

## Common Patterns

### Adding a New Feature
1. Identify the correct component file
2. Add the function to that component
3. Export it in the return statement
4. Update state if needed
5. Call render() if UI changes
6. Add tests for the new feature

### Deleting Records
Always consider cascading deletes:
- Deleting a client â†’ delete all projects and invoices
- Deleting a project â†’ delete all invoices
- Show confirmation dialogs in Hebrew

### Form Handling
```javascript
// Pattern for adding/editing records
state.newItem = { field1: '', field2: '' };
state.showNewItem = true;
render();

// On submit
async function addItem() {
    const data = state.newItem;
    // Validate
    // Save to Firestore
    // Update state
    // Reset form
    state.showNewItem = false;
    render();
}
```

## Project-Specific Business Logic

### Order Numbers
- Format: YY/XXX (year/sequence)
- Example: 24/001, 24/002
- Auto-generated, sequential

### Project Calculations
Use `calculateTotals()` for:
- Total expenses (orders + invoices + work assignments)
- Profit (revenue - expenses)
- Profit margin percentage

### Work Schedule (Sidur)
- Track workers by date
- Daily rates per worker
- Link to projects
- Calculate worker expenses per project

## Constants

### Available Constants (from shared/constants.js)
- `categories` - Item categories (×‘×˜×•×Ÿ, ×›×‘×œ×™×, ×¦×™× ×•×¨×•×ª, etc.)
- `projectStatuses` - Project statuses (×¤×ª×•×—, ×‘×‘×™×¦×•×¢, ×”×•×©×œ×, etc.)
- `workers` - Worker list (×™××¡×¨, ×¤×¨×™×“, ××—××“, etc.)
- `units` - Measurement units (×™×—', ××˜×¨, ××˜×¨ ××¨×•×‘×¢, etc.)

Always use these constants rather than hardcoding values.

## Debug Mode

### Development Logging
```javascript
if (context.isDevelopment) {
    console.log('Debug info:', data);
}
```

## Version Control

### âš ï¸ CRITICAL Git Workflow Rules

**ALWAYS APPLY: Branch Protection**
- âŒ NEVER make changes directly to `main` branch
- âœ… ALWAYS start a new branch for any changes
- âœ… Branch naming: descriptive-feature-name (e.g., `settings-fix`, `add-client-search`, `order-pdf-update`)
- âœ… ALWAYS merge to main ONLY when the user explicitly instructs
- âš ï¸ Wait for user approval before merging any branch to main

**Use WSL for Git Commands**
- All git operations should use WSL (Windows Subsystem for Linux)
- Example: `wsl git checkout -b new-feature`
- Example: `wsl git add .`
- Example: `wsl git commit -m "message"`
- Example: `wsl git push origin branch-name`

### Git Practices
- Keep commits focused and atomic
- Write descriptive commit messages
- Update CHANGELOG.md for significant changes
- Don't commit node_modules or sensitive files
- Create feature branches from main
- Test thoroughly before requesting merge

## Deployment

### Firebase Deployment
- âš ï¸ **ALWAYS use `firebase deploy` command directly, NOT `npm run deploy`**
- Deploy command: `firebase deploy`
- Deploy specific targets: `firebase deploy --only hosting` or `firebase deploy --only functions`

### Deployment & Testing Workflow
**CRITICAL: Deploy branches to production for testing**

1. **Feature Branch Deployment**
   - Deploy feature branch directly to production: `firebase deploy`
   - The deployed branch will be live on production
   - Perform manual testing on production

2. **Manual Testing on Production**
   - Test all new features thoroughly
   - Verify existing functionality still works
   - Check UI/UX in production environment
   - Test edge cases and error scenarios
   - Verify Hebrew RTL display
   - Check responsive design on mobile/desktop

3. **After Successful Testing**
   - If all tests pass â†’ ready for merge to main
   - Wait for user approval to merge
   - After merge â†’ deploy main branch
   - Main branch becomes the stable production version

4. **If Testing Fails**
   - Fix issues on the feature branch
   - Commit and push fixes
   - Deploy feature branch again
   - Re-test on production
   - Repeat until all tests pass

### Deployment Checklist
- âœ… Deploy branch: `firebase deploy`
- âœ… Test manually on production
- âœ… Verify all features work
- âœ… Check console for errors
- âœ… Test user flows
- â¸ï¸ Request merge approval from user
- âœ… After approval, merge to main
- âœ… Deploy main branch

---

## Quick Reference

### File Location Cheatsheet
- Add client code â†’ `components/clients.js`
- Add project code â†’ `components/projects.js`
- Add order code â†’ `components/orders.js`
- Add supplier code â†’ `components/suppliers.js`
- Add work schedule code â†’ `components/sidur.js`
- Add shared constants â†’ `shared/constants.js`
- Add helper functions â†’ `shared/utils.js`
- Modify state structure â†’ `shared/state.js`
- App initialization â†’ `app.js`

### Common Commands
- Test: `npm test`
- Test with coverage: `npm test:coverage`
- Serve locally: `firebase emulators:start`
- Deploy: `firebase deploy` (NOT npm run deploy)
- Git commands: Use WSL (e.g., `wsl git status`)

### Git Workflow Checklist
1. âœ… Create feature branch: `wsl git checkout -b feature-name`
2. âœ… Make changes and commit: `wsl git commit -m "description"`
3. âœ… Push: `wsl git push origin feature-name`
4. âœ… Deploy branch to production: `firebase deploy`
5. âœ… Test manually on production (deployed branch)
6. âœ… Verify all functionality works in production
7. â¸ï¸ Wait for user to approve merge to main
8. âœ… After approval, merge to main
9. âœ… Deploy main branch: `firebase deploy`

### Complete Development Cycle Example
```
# Start new feature
wsl git checkout -b add-client-search

# Make changes, code the feature
# ... edit files ...

# Commit changes
wsl git add .
wsl git commit -m "Add client search functionality"
wsl git push origin add-client-search

# Deploy feature branch to production for testing
firebase deploy

# Manual testing on production
# - Open production URL
# - Test client search feature
# - Verify it works correctly
# - Check for any bugs

# If tests pass, ready for merge
# Wait for user approval

# After user approval
wsl git checkout main
wsl git merge add-client-search
wsl git push origin main

# Deploy stable main branch
firebase deploy
```

Remember: 
- This is a modular system designed to avoid merge conflicts. Keep features in their respective component files!
- NEVER commit directly to main branch
- ALWAYS wait for user approval before merging to main
- Footer must show version and branch name

